# -*- coding: utf-8 -*-
"""HTB-AI_in_InfoSec_spam_classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gBuWdJo9noRFtYx8ImShGipmEX9djAbu
"""

import requests
import json
import os
import pandas as pd
import requests
import zipfile
import io
import numpy as np
import re
import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
import joblib
nltk.download('punkt_tab')
nltk.download('stopwords')

"""#Loading and extracting data"""

# URL of the dataset
url = "https://archive.ics.uci.edu/static/public/228/sms+spam+collection.zip"

# Download the dataset
response = requests.get(url)

if response.status_code == 200:
    print("Download successful")

    # Create an in-memory byte stream from the downloaded content
    zip_file = zipfile.ZipFile(io.BytesIO(response.content))

    # Define a directory to extract the files into
    extraction_path = "sms_spam_collection"

    # Extract all the contents of the zip file to the specified directory
    zip_file.extractall(extraction_path)

    print(f"Extraction successful to '{extraction_path}'")

    # List the extracted files
    extracted_files = os.listdir(extraction_path)
    print("Extracted files:", extracted_files)

else:
    print("Failed to download the dataset")
# Load the dataset
df = pd.read_csv(
    "sms_spam_collection/SMSSpamCollection",
    sep="\t",
    header=None,
    names=["label", "message"],
)

"""Pre-processing"""


# Preprocess function that mirrors the training-time preprocessing
def preprocess_message(message):
    stop_words = set(stopwords.words('english'))
    stemmer = PorterStemmer()
    message = message.lower()
    message = re.sub(r"[^a-z\s$!]", "", message)
    tokens = word_tokenize(message)
    tokens = [word for word in tokens if word not in stop_words]
    tokens = [stemmer.stem(word) for word in tokens]
    return " ".join(tokens)

df.message = df.message.apply(preprocess_message)

"""#Feature Extraction"""

# Initialize CountVectorizer with bigrams, min_df, and max_df to focus on relevant terms
vectorizer = CountVectorizer(min_df=1, max_df=0.9, ngram_range=(1, 2))

# Fit and transform the message column
X = vectorizer.fit_transform(df["message"])

# Labels (target variable)
y = df["label"].apply(lambda x: 1 if x == "spam" else 0)  # Converting labels to 1 and 0

# Build the pipeline by combining vectorization and classification
pipeline = Pipeline([
    ("vectorizer", vectorizer),
    ("classifier", MultinomialNB())
])

param_grid = {
    "classifier__alpha": [0.01, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1.0]
}
grid_search = GridSearchCV(
    pipeline,
    param_grid,
    cv=5,
    scoring="f1"
)

# Fit the grid search on the full dataset
grid_search.fit(df["message"], y)

# Extract the best model identified by the grid search
best_model = grid_search.best_estimator_
print("Best model parameters:", grid_search.best_params_)
model_file_path = 'spam_detection_model.joblib'
joblib.dump(best_model, model_file_path)

print(f"Model saved to {model_file_path}")

model_file_path = 'spam_detection_model.joblib'

new_messages = [
    "Congratulations! You've won a $1000 Walmart gift card. Go to http://bit.ly/1234 to claim now.",
    "Hey, are we still meeting up for lunch today?",
    "Urgent! Your account has been compromised. Verify your details here: www.fakebank.com/verify",
    "Reminder: Your appointment is scheduled for tomorrow at 10am.",
    "FREE entry in a weekly competition to win an iPad. Just text WIN to 80085 now!",
]

best_model = joblib.load(model_file_path)
predictions = best_model.predict(new_messages)

processed_messages = [preprocess_message(msg) for msg in new_messages]
X_new = best_model.named_steps["vectorizer"].transform(processed_messages)
predictions = best_model.named_steps["classifier"].predict(X_new)
prediction_probabilities = best_model.named_steps["classifier"].predict_proba(X_new)

for i, msg in enumerate(new_messages):
    prediction = "Spam" if predictions[i] == 1 else "Not-Spam"
    spam_probability = prediction_probabilities[i][1]  # Probability of being spam
    ham_probability = prediction_probabilities[i][0]   # Probability of being not spam

    print(f"Message: {msg}")
    print(f"Prediction: {prediction}")
    print(f"Spam Probability: {spam_probability:.2f}")
    print(f"Not-Spam Probability: {ham_probability:.2f}")
    print("-" * 50)

import requests
import json

# Define the URL of the API endpoint

hostname = "localhost"
url = f'http://{hostname}:8000/api/upload'

# Path to the model file you want to upload
model_file_path = "spam_detection_model.joblib"

# Open the file in binary mode and send the POST request
with open(model_file_path, "rb") as model_file:
    files = {"model": model_file}
    response = requests.post(url, files=files)

# Pretty print the response from the server
print(json.dumps(response.json(), indent=4))